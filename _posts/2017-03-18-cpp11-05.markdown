---
layout:     post
title:      "深入理解C++11（笔记）：第五章 提高类型安全"
subtitle:   " \"First step.\""
date:       2017-03-18 9:37
header-img: "img/post-bg-2015.jpg" 
tags:
    - c++
---

> "Let's begin!"

> 相比于C语言，C++则更为强调类型，其目的是为了在构建复杂的软件系统时，能够尽可能地在编译时期找到错误并提醒程序员

### 5.1 强类型枚举

#### 5.1.1 枚举：分门别类与数值的名字

> 在C\+\+中，更受推荐的是--静态常量

```cpp
    const static int Male = 0;
        const static int Female = 1;
        ```

#### 5.1.2 强类型枚举以及C\+\+11对原有枚举类型的扩展

        > 非强类型作用域，允许饮食转换为整形，占用存储空间以及符号性不确定，都是枚举类的缺点

        ```cpp
        // 声明强类型美剧非常简单，只需要在enum后加上关键字class
        enum class Type { General, Light, Medium, Heavy };

强类型枚举具有以下几点优势：
· 强作用域，强类型美剧成员的名称不会被输出到其父作用域空间。
· 转换限制，强类型枚举成员的值不可以与整型隐式相互转化
· 可以制定底层类型，比如：
enum class Type:char {General, Light, Medium, Heavy};
```

### 5.2 堆内存内存管理：智能指针与垃圾回收

#### 5.2.1 显式内存管理

> 虽然显式的管理内存在性能上有一定的优势，但也被广泛地认为是容易出错的。有期是多线程程序的出现和广泛使用，内存管理不佳的情况还可能会变的更加严重。

#### 5.2.2 C\+\+11的智能指针

> C\+\+98中的auto_ptr已被废弃。C\+\+11中该用unique_ptr、shared_ptr及weak_ptr等智能指针来自动回收堆分配的对象

> unique_ptr形如其名，与所指对象的内存绑定紧密，不能与其他unique_ptr类型的指针对象共享所对象的内存。这种“所有权”仅能够通过标准库的++move++函数来转移。

> weak_ptr的使用更为复杂一点，它可以只想shared_ptr指针之乡的对象内存，却并不拥有该内存。

#### 5.2.3 垃圾回收的分类

#### 5.2.4 C\+\+与垃圾回收

