---
layout: post
title: 深入理解C++11（笔记）：第二章 保证稳定性与兼容性
subtitle: ' "稳定性与兼容性."'
date: '2016-12-19 13:39'
header-img: img/post-bg-2015.jpg
tags:
  - c++
published: true
---
> "Let's begin!"  

### 2.1 保持与C99兼容  
  
#### 2.1.1 预定义宏  
宏名称 | 功能描述
-----------|-------------------
\_\_STDC\_HOSTED\_\_  | 如果编译器的目标系统环境中包含完整的标准C库，那么这个宏就定义为1，否则宏的值为0
\_\_STDC\_\_  | C编译器中通常用这个宏的值来表示编译器的实现是否和C标准一致。
\_\_STDC\_VERSION\_\_  | C编译器通常用这个宏来表示所支持的C标准的版本  

    如果用户重定义（#define）或（#undef）了预定义的宏，那么后果就是“未定义”的。  

#### 2.1.2 __ func __ 预定义标识符  
*其基本功能就是返回所在函数的名字。*  

```cpp
#include <string>
#include <iostream>
using namespace std;
const char *hello() { return __func__; }
const char *world() { return __func__; }
int main()
{
	cout << hello() << "," << world() << endl;
}
// 编译选项：g++ -std=c++11 xx.cpp
```  

```cpp
// 下面的方式是可行的
struct TestStruct {
	TestStruct() : name(__func__) {}
	const char *name;
}
// 但是这样的形式是无法通过编译的
void FuncFail(string func_name = __func__) {}
// 这是由于在参数声明时，__func__还未被定义
```  

#### 2.1.3 _Pragma 操作符
在C\+\+11中，准定义了与预处理指令#pragma功能相同的操作符_Pragma。  
**\#pragma once等同于\_Pragma("once")**  
相比于预处理指令#pragma，由于\_Pragma是一个操作符，因此可以用在一些宏中。而\#pragma不能在宏中展开，C++11的\_Pragma具有更大的灵活性。  
```cpp
#define ON CE("on")
#define CE(x) _Pargma(#x"ce")
ON          // 等同于#pragma once
```  

#### 2.1.4 变长参数的宏定义以及\_\_VA\_ARGS\_\_
在C99标准中，程序员可以使用变长参数的宏定义。  

    #define PR(...) printf(__VA_ARGS__)  

#### 2.1.5 宽窄字符串的连接  
窄字符串（char）转换成宽字符串（wchar_t）在之前的C\+\+标准中是未定义的行为。支持C\+\+11标准的编译器会将窄字符串转换成宽字符串，然后再与宽字符串进行连接。  

### 2.2 long long整型
```cpp
#include <climits>
#include <cstdio>
using namespace std;
int main()
{
    long long ll_min = LLONG_MIN;
    long long ll_max = LLONG_MAX;
    unsigned long long = ULLONG_MAX;
}
```  

### 2.3 扩展的整型
> C++11一共只定义了以下5种标准的有符号整数：  

    signed char、 short int、 int、 long int、 long long int  

### 2.4 宏\_\_cplusplus  
在C\+\+11中，\_\_cplusplus被预定义为201103L。  

```cpp
#if __cplusplus < 201103L
    #error "should use C++11 implementation"
#endif
```  
预处理指令\#error，使得非c++11标准的编译器立即报错并终止编译。  

### 2.5 静态断言
