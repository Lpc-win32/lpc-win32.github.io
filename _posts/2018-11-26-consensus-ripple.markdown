---
layout:     post
title:      "一致性算法 - Ripple共识算法RPCA "
subtitle:   " \"Ripple Consensus Algorithm\""
date:       2018-11-26 19:34
header-img: "img/post-bg-unix-linux.jpg"
author:     "pepperliu"
catalog:      true
tags:
    - 分布式
    - consensus
    - Hawala
    - Ripple
    - RPCA
---

### 1. Hawala

哈瓦拉是独立于传统银行金融渠道的非正统、非主流的汇款系统。哈瓦拉一词（Hawala）的阿拉伯语含义是指“约定好的票据”或“交易用的账单”，后来这个词又进入了印地语并增加了“信任”、“介绍”、“推荐”等新含义

![Hawala](http://blog.lpc-win32.com/img/2018-11-26/1.png)

由上图可知：Alex转帐5美金给Beth需要如下步骤：

- Alex支付5美金（一定的手续费）给到他的代理A
- 代理A通知Beth的代理B：Alex给Beth转帐了5美金
- Beth从他的代理B提取5美金

结果：AgenA欠AgentB 5美金，Agent之间可以定期计算（解决IOU）

支撑Hawala系统正常运转的三个信任关系如下：

- Alex和代理A
- Beth和代理B
- 代理之间的信任

### 2. Ripple

借鉴hawala系统思想， Ripple（瑞波）的出现让货币在全球范围内的流通变得更加简单方便了。Ripple 是一种互联网交易协议，它允许人们用任意一种货币进行支付。例如，甲方可以利用Ripple 以美元支付，而乙方则可以通过Ripple 直接收取欧元

![Ripple](http://blog.lpc-win32.com/img/2018-11-26/2.png)

在Ripple场景下Alex转帐给Beth需要经过如下步骤：

- Alex登陆Ripple网关AgentA，存入cash，发送转帐请求
- AgentA寻找一条路径（可能包含AgentC等），找到Beth的网关接入点
- Beth收到cash

Ripple 网络作为 Ripple 的核心，是一个共享的公开数据库。数据库中有记录着账号和结余的总账。任何人都可以阅读这些总账，也可以读取 Ripple 网络中的所有交易活动记录

### 3. RPCA

Ripple共识算法 RPCA （Ripple Consensus Algorithm）

#### 3.1 RPCA基本概念

服务节点：可以接收交易的区块链节点，包括验证节点和非验证节点验证节点是被其它节点接入到信任列表中的节点，参与共识过程。非验证节点不参与共识工程

区块用于记录交易，在RPCA中有两种区块比较关键：

- 最新关闭区块：也就是最新被共识过的区块
- 开放区块：也就是当前正在被共识的区块，当开放区块被共识过，也就成了最新关闭区块

信任节点列表UNL（unique node list）：每个服务节点都会维护一个信任节点列表，这里信任并不是指信任每一个节点， 而是指信任这个列表中的节点不会联合起来作弊。在共识过程中，我们只接受来自信任节点列表中的节点投票。在Ripple中，使用配置文件中加入其它验证节点的公钥的方式来制定UNL

非验证节点：主要功能包括交易分发和查询帐本；验证节点除了可以完成交易分发和查询帐本的基本功能，还要参与共识工程

客户端应用提交交易请求给服务节点（Rippled），服务节点以最近验证过的帐本为依据进行交易检查，检查通过的交易进入候选交易集合  
服务节点转发候选交易集给它的Peers，将候选交易集在整个Ripple网络传播   
实际上，由于交易在Peer间传播需要时间，所有的服务节点基本上不可能每次都获得相同的候选交易集。XRP Ledger 使用共识来解决帐本一致性问题

#### 3.2 RPCA共识过程

Ripple网络每隔几秒就会产生一个新的区块，这个区块的产生过程就是所有网络节点RPCA共识的过程。假设共识过程是成功的，并且网络中没有分叉产生，那么新生成的区块就是全网唯一的

整个RPCA共识过程分为如下两个阶段：

- 交易共识，形成交易集
- 区块打包，再共识

##### 3.2.1 交易共识，形成交易集

1. 每个验证节点在共识开始时，尽可能多的收集需要共识的交易，放到候选交易集里，并将候选交易列表发送给Peers
2. 每个节点对它信任节点列表中的 “候选集”做一个并集，并对每一个交易进行投票
3. UNL中的服务节点交流交易的投票结果，达到一定投票比例的交易会进入到下一轮，达不到比例的交易要么被丢弃，要么进入到下一次共识过程的候选集中
4. 在最终轮中，所有投票超过80%的交易会被放到共识过的交易集中，这里的交易集与比特币类似，也是Merkle树的数据结构

![RPCA](http://blog.lpc-win32.com/img/2018-11-26/3.png)

##### 3.2.2 区块打包，再共识

形成交易集后，每个节点开始打包新的区块，打包区块的过程如下：

![RPCA](http://blog.lpc-win32.com/img/2018-11-26/4.png)

![RPCA](http://blog.lpc-win32.com/img/2018-11-26/5.png)

1. 把当前区块号、共识交易集的Merkle树根Hash、父区块Hash、当前时间戳等内容放到一起，计算一个区块哈希
2. 每个节点广播自己得出的区块哈希到它可见的节点，这里的可见节点不仅仅指可信列表中的节点，而是通过节点发现过程能发现的节点
3. 节点收集到它所有可信列表中节点广播过来的区块哈希后，结合自己生成的区块哈希，对每个区块哈希计算一个比例，如果某一哈希的比例超过一个阈值（一般是80%），则认为这个哈希是共识通过的区块哈希。如果自己的哈希与之相同，则说明自己打包的区块得到了确认，是新的被共识过的区块，直接存到本地，并且更新状态。如果自己的哈希与共识通过的哈希不同，那就需要去某个区块哈希正确的节点索要新的区块信息，要到之后存储到本地并且更新当前状态
4. 如果上面没有对某一区块哈希超过设定的阈值，那么重新开始共识过程，直到满足条件

#### 3.3 RPCA验证

下面我们开始依次验证正确性、一致性、可用性：

- 正确性

RPCA中正确性的验证方式很简单，因为共识需要80%的阈值，那么只要UNL中有80%的诚实节点，就能达成共识，另外即使有超过20%的欺诈节点，也不能破坏正确性，因为欺诈节点也必须达到80%以上才能达成共识。无论欺诈节点还是诚实节点，达不到80%，都无法通过共识

- 一致性

RPCA中一致性是通过子网络与其它子网络的连通性来保证的，要保证区块链不分叉，必须确保每个子网络必须至少与整个网络节点中的20%保持连通性。达到20%连通性的前提下，如果一个子网络中得出的共识区块哈希与整个网络得出的不一致，也就无法达成80%的共识要求，也就无法产生分叉

![RPCA](http://blog.lpc-win32.com/img/2018-11-26/6.png)

- 可用性

在每一轮投票过程中，节点会搜集它UNL中每个节点的响应时间，一直响应时间慢的节点将会被剔除出去，这样UNL就能保持一个较高的沟通效率。在高效沟通的前提下，RPCA算法能保证每3秒左右就能产生一个区块，Ripple官方给出的tps数据是1500。这样的性能基本能满足一般的生产需求
