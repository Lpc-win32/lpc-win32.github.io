---
layout:     post
title:      "Kademlia DHT"
subtitle:   " \"Kademlia DHT是分布式哈希表的一种实现\""
date:       2018-10-12 14:14
header-img: "img/post-bg-blockchain.jpg" 
author:     "pepperliu"
catalog:      true
tags:
    - ethereum
    - blockchain
    - dht
    - kad
    - kademlia
---

### 1. 分布式哈希表（DHT）

DHT(Distributed Hash Table)主要思想如下：全网维护一个巨大的文件索引哈希表，这个哈希表的条目如(Jey, Value)。这里的Key通常是文件的某个哈希算法下的哈希值，而Value则是存储文件的IP地址。查询是，仅需要提供Key，就能从表中查询到存储到节点地址并返回给查询节点。

### 2. Kademlia DHT

Kademlia DHT是分布式哈希表的一种实现，其用以偶一些很好的特性，如：

- 节点ID与关键字是同样的值域，都是使用SHA-1算法生成的160位摘要，这样大大简化了查询时的信息量，更便于查询
- 可以使用XOR异或运算，计算任意两个节点的举例或是节点和关键字的举例
- 查找一条请求路径的时候，每个节点的信息是晚辈的，只需要进行Log(n)量级次跳转
- 可根据查询速度和存储量的需求，调整每个节点需要维护的DHT大小

一个新来的网络节点在初次连接网络会分配一个ID，每个几点自身维护一个路由表和一个DHT，这个路由表保存网络中一部分节点的连接信息，DHT用于存放文件信息。每个网络节点优先存储离自己更近的节点信息，至少保存k个(k是常数)，我们称作K-Buket。每个网络节点需要优先存储自己的ID，距离较小的文件。每次检索时，将查询文件的Hash与自己的ID求距离，然后扎偶哦这个距离对应的K-Buket，向Kbin中的节点查询。接受查询的节点也做同样的检查，如果发现自己存有这一个数据，便将其返回给查询的节点

### 3. Kademlia二叉状态树

Kademlia网络的节点ID是由一颗二叉树维护，我们最终生成的二叉树需要如下要求：
- 每个网络节点可以从根节点出发，沿着它的最短唯一前缀到达
- 每个网络节点都应该是叶子节点

![image](http://blog.lpc-win32.com/img/2018-10-25/kademlia-01.png)

在Kademlia中，每个DHT条目包含key\-value对。Key是文件的Hash值，Value是节点ID。Key与Value有相同的值域，都是160位。每一个新加入网络的计算机都会被随机分配一个节点的ID值。数据存放在Key值域ID值“最接近”key值得节点上”。这样，我们就需要定义它们的远近了。XOR运算可以很好的解决节点之间远近的问题

![image](http://blog.lpc-win32.com/img/2018-10-25/kademlia-02.png)

### 4. 节点路由表K\-Buket

> 节点路由表用于保存每个节点与自己一定距离范围内其他节点的连接信息。

每一条路由信息由如下3部分组成：

- IP Address
- UDP Port
- Node ID

KAD路由表将距离分成160个K桶（存放K个数据的桶），分开存储。因此（每个桶存的数据量K是需要考量的）

当节点x收到一个消息时，发送者y的IP地址就被用来更新对应的K桶，具体步骤如下

1. 计算自己和发送者的ID距离（通过使用XOR方法）
2. 通过距离d选择对应的K桶进行更新操作
3. 如果y的IP地址已经存在于这个K桶中，则把对应项移到该K桶的尾部。如果y的UO地址没有记录在K桶中，则执行如下操作

![image](http://blog.lpc-win32.com/img/2018-10-25/kademlia-03.png)

K桶的更新机制非常高效的实现了一种把最近看到的节点更新的策略，除非在线节点一直未从K桶中移出过。也就是说在线时间长的节点具有较高的可能性继续保留在K桶列表中。

这种机制是基于对Gnutella网络上大量用户行为习惯的研究结果，既节点的失效概率和在线时长成反比。

![image](http://blog.lpc-win32.com/img/2018-10-25/kademlia-04.png)

#### 4.1 路由查询机制

Kad技术的最大特点之一就是能够提供快速的节点查找机制，并且还可以通过参数进行查找速度的调节。如果节点x要查找ID值为t的节点，Kad按照如下递归操作步骤进行路由查找：

- 计算到t的距离（XOR）\-\> d
- 从x的第log(d)个K桶中取出a个节点的信息，同事进行FIND\_NODE操作。如果这个K桶中的信息少于a个，则从附近多个同种选择距离最接近d的总共a个节点
- 对接受到查询操作的每个节点，如果发现自己就是t，则回答自己是最接近t的。否则测量自己和t的距离，并从自己对应的K桶中选择a个节点的信息交给x
- x对新接收到的每个节点都再次进行FIND\_NODE操作，此过程不断重复执行，指导每一个分支都有节点响应自己是最接近t的
- 通过上述查找操作，x得到了k个最接近t的节点信息

#### 4.2 节点加入和离开

如果节点u想加入Kad网络，它必须要和一个已经在Kad网络的节点，比如w，取得联系。u首先把w插入自己适当的K桶中，然后对自己的节点ID执行一次FIND\_NODE操作，然后根据接收到的信息更新自己的K桶内容。通过对自己临近节点由近及远的逐步查询，u完成了仍然是空的K桶信息的创建，同时把自己的信息发布到其他节点的K桶中。在Kad网络中，每个节点的路由表都表示为一颗二叉树，叶子节点为K桶，K桶存放的是有相同ID前缀的节点信息，而这个前缀就是该K桶在二叉树中的位置。这样，每个K桶都覆盖了ID空间的一部分，全部K桶的信息加起来就覆盖了整个160bit的空间，而且没有重叠

以节点u为例，其路由表的生成过程为：

- 最初，u的路由表为一个单个的K桶，覆盖了整个160bitID空间
- 当学习到新的节点信息后，则u会尝试把心节点的信息，根据其前缀值插入到对应的K桶中

![image](http://blog.lpc-win32.com/img/2018-10-25/kademlia-05.png)

- 上述过程不断重复，直到满足路由表的要求。打到距离近的节点的信息多，距离远的节点的信息少的结果，保证了路由查询过程能快速收敛

节点离开Kad网路不需要发布任何信息，等待节点离线的时间足够长，其他网络节点访问它失效后，便自动将其移出各自的路由表，那么这一节点就离开了