---
layout:     post
title:      "一致性算法 - PBFT（实用拜占庭容错系统）"
subtitle:   " \"区块链中最常用的强一致性算法——实用拜占庭容错（PBFT）算法\""
date:       2018-11-22 19:46
header-img: "img/post-bg-unix-linux.jpg"
author:     "pepperliu"
catalog:      true
tags:
    - 分布式
    - consistent
    - BFT
    - PBFT
---

> 实用拜占庭容错系统（PBFT）降低了拜占庭协议的运行复杂度，从指数级别降低到多项式级别（Polynomial），使拜占庭协议在分布式系统中应用成为可能

### 1. 先来通俗的认识一下PBFT

PBFT算法要求至少要4个参与者（满足3n+1的个数，n最小为1）一个被选举为组长，3个组员。组长接到语文老师命令：你们开始开始背《三字经》。组长就会给3个组员发命令背《三字经》。3个组员收到消息后会执行命令，并汇报结果给班主任。首先，班长会以身作则完整背诵过《三字经》，A组员说我已经可以完整背诵《三字经》了，B组员说我已经可以完整背诵《三字经》了，C组员说我还不能完整背诵《三字经》。班主任知道了2n+1的同学都可以完整背诵《三字经》所以班主任就会忽略C组员的汇报结果。开始让同学们随堂默写《三字经》。这就是PBFT算法

### 2. PBFT简介

PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。

通常假设故障节点数为m个，整个服务节点数为\|R\|\=3m\+1个，这里m是有可能失效的副本的最大个数。尽管可以存在多于3m\+1个副本，但是额外的副本除了降低性能之外不能提高可靠性

> 因此，推荐的副本数量为3m+1个

### 3. PBFT协议通信模式

PBFT要求共同维护一个状态，所有节点采取的行动一致。为此，需要运行三类基本协议，包括一致性协议、检查点协议和视图更换协议。我们主要关注支持系统日常运行的一致性协议

一致性协议至少包含如下若干个阶段：

- 请求（request）
- 序号分配（pre-prepare）
- 响应（reply）

根据协议设计的不同，可能包含如下阶段：

- 相互交互（prepare）
- 序号确认（commit）

![PBFT协议通信模式](http://blog.lpc-win32.com/img/2018-11-22/5.png)

由于客户端不能从服务器端获得任何服务器运行状态的信息，PBFT中主节点是否发生错误只能由服务器监测。如果服务器在一段时间内都不能完成客户端的请求，则会触发视图更换协议。其中C为客户端，0~3表示服务节点，特别的，0为主节点，3为故障节点。

在发送消息的时候通过环境状态、时间戳、请求、回复信息，客户端同样等待 2f+1 个回复，同时保证签名、时间戳、回复信息来保证一致

这里存在两种情况，一种是客户端请求超时，那就再发送一次，如果是主节点0出故障，那就改变环境状态，重新选一个0节点。保证第二次的执行过程

整个协议的基本过程如下：

1） 客户端发送请求，激活主节点的服务操作

2） 当主节点接收请求后，启动三阶段的协议以向各从节点广播请求（实际的交互阶段，PBFT的核心步骤）

- 序号分配阶段（pre\-prepare）：主节点给请求赋值一个序列号n，广播序号分配消息和客户端的请求消息m，并将构造PRE-PREPARE消息给各从节点。发送格式（环境状态、ID、信息摘要、客户端请求），从节点验证信息摘要和客户端请求一致，验证当前环境状态编号
- 交互阶段（prepare）：从节点接收PRE-PREPARE消息，向其他服务节点广播PREPARE消息。主节点和从节点同时验证消息签名，如果一致，那么就把验证通过写入消息日志。每个节点在准备阶段对每个副本节点验证预准备的消息和准备消息一致性检查完毕
- 序号确认阶段（commit）：在前面两个阶段一切正常的话，在同一系统环境中，所有请求序号一致，验证消息一致，简单理解就是确认 2f\+1 个节点发送了之前发送的序号和消息

3) 客户端等待来自不同节点的响应，若有m\+1个响应相同，则该响应即为运算的结果

### 4. 从区块链的角度理解PBFT

![PBFT协议通信模式](http://blog.lpc-win32.com/img/2018-11-22/5.png)

从上图可知，C是客户端，0、1、2、3 是分布式系统中的节点成员，其中由 0 节点提议区块，1、2、3节点对提议出来的区块进行投票，其中 3 节点已发生故障。我们默认3发送信息为无效。那么PBFT算法执行的流程如下：

- C发起一笔请求到0号节点
- 节点0开始对请求排序编号，并把请求序号发送到1、2、3节点
- 1、2节点互相之间和0节点之间发送消息
- 0、1、2之间确认0节点的分配序号，互相确认
- 0、1、2确认信息回复C
- 客户端C判断收到确认是否在2f\+1内，确认结果

在每一轮共识分三个阶段达成共识（核心步骤）：Pre\-Prepare、Prepare和Commit，整个流程如下：

- 从全网节点选举出一个提议节点（Proposer），新区块由提议节点负责生成
- 每个节点把客户端发来的交易向全网广播，提议节点将从网络收集到需放在新区块内的多个交易排序后存入列表，并将该列表向全网广播
- 每个节点接收到交易列表后，根据排序模拟执行这些交易。所有交易执行完后，基于交易结果计算新区块的哈希摘要，并向全网广播
- 如果一个节点收到的2f条来自其它节点发来的摘要都和自己的相同，就向全网广播一条commit消息
- 如果一个节点收到2f\+1条commit消息，即可提交新区块及其交易到本地的区块链和状态数据库

> 认真读完上面的三阶段共识步骤，你就会明白PBFT为什么这么快

#### 4. 小结

PBFT在很多场景都有应用，在区块链场景中，一般适合于对强一致性有要求的私有链和联盟链场景。例如，在IBM主导的区块链超级账本项目中，PBFT是一个可选的共识协议。在Hyperledger的Fabric项目中，共识模块被设计成可插拔的模块，支持像PBFT、Raft等共识算法
