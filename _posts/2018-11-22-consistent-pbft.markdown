---
layout:     post
title:      "一致性算法 - PBFT（实用拜占庭容错系统）"
subtitle:   " \"区块链中最常用的强一致性算法——实用拜占庭容错（PBFT）算法\""
date:       2018-11-22 19:46
header-img: "img/post-bg-unix-linux.jpg"
author:     "pepperliu"
catalog:      true
tags:
    - 分布式
    - consistent
    - BFT
    - PBFT
---

> 实用拜占庭容错系统（PBFT）降低了拜占庭协议的运行复杂度，从指数级别降低到多项式级别（Polynomial），使拜占庭协议在分布式系统中应用成为可能

### 1. 先来通俗的认识一下PBFT

PBFT算法要求至少要4个参与者（满足3n+1的个数，n最小为1）一个被选举为组长，3个组员。组长接到语文老师命令：你们开始开始背《三字经》。组长就会给3个组员发命令背《三字经》。3个组员收到消息后会执行命令，并汇报结果给班主任。首先，班长会以身作则完整背诵过《三字经》，A组员说我已经可以完整背诵《三字经》了，B组员说我已经可以完整背诵《三字经》了，C组员说我还不能完整背诵《三字经》。班主任知道了2n+1的同学都可以完整背诵《三字经》所以班主任就会忽略C组员的汇报结果。开始让同学们随堂默写《三字经》。这就是PBFT算法

### 2. PBFT简介

PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。

通常假设故障节点数为m个，整个服务节点数为\|R\|\=3m\+1个，这里m是有可能失效的副本的最大个数。尽管可以存在多于3m\+1个副本，但是额外的副本除了降低性能之外不能提高可靠性

> 因此，推荐的副本数量为3m+1个

### 3. PBFT协议通信模式

PBFT要求共同维护一个状态，所有节点采取的行动一致。为此，需要运行三类基本协议，包括一致性协议、检查点协议和视图更换协议。我们主要关注支持系统日常运行的一致性协议

一致性协议至少包含如下若干个阶段：

- 请求（request）
- 序号分配（pre-prepare）
- 响应（reply）

根据协议设计的不同，可能包含如下阶段：

- 相互交互（prepare）
- 序号确认（commit）

![PBFT协议通信模式](http://blog.lpc-win32.com/img/2018-11-22/5.png)

由于客户端不能从服务器端获得任何服务器运行状态的信息，PBFT中主节点是否发生错误只能由服务器监测。如果服务器在一段时间内都不能完成客户端的请求，则会触发视图更换协议。其中C为客户端，0~3表示服务节点，特别的，0为主节点，3为故障节点。

在发送消息的时候通过环境状态、时间戳、请求、回复信息，客户端同样等待 2f+1 个回复，同时保证签名、时间戳、回复信息来保证一致

这里存在两种情况，一种是客户端请求超时，那就再发送一次，如果是主节点0出故障，那就改变环境状态，重新选一个0节点。保证第二次的执行过程

整个协议的基本过程如下：

1） 客户端发送请求，激活主节点的服务操作

2） 当主节点接收请求后，启动三阶段的协议以向各从节点广播请求（实际的交互阶段，PBFT的核心步骤）

- 序号分配阶段（pre\-prepare）：主节点给请求赋值一个序列号n，广播序号分配消息和客户端的请求消息m，并将构造PRE-PREPARE消息给各从节点。发送格式（环境状态、ID、信息摘要、客户端请求），从节点验证信息摘要和客户端请求一致，验证当前环境状态编号
- 交互阶段（prepare）：从节点接收PRE-PREPARE消息，向其他服务节点广播PREPARE消息。主节点和从节点同时验证消息签名，如果一致，那么就把验证通过写入消息日志。每个节点在准备阶段对每个副本节点验证预准备的消息和准备消息一致性检查完毕
- 序号确认阶段（commit）：在前面两个阶段一切正常的话，在同一系统环境中，所有请求序号一致，验证消息一致，简单理解就是确认 2f\+1 个节点发送了之前发送的序号和消息

3) 客户端等待来自不同节点的响应，若有m\+1个响应相同，则该响应即为运算的结果

### 4. 从区块链的角度理解PBFT

![PBFT协议通信模式](http://blog.lpc-win32.com/img/2018-11-22/5.png)

从上图可知，C是客户端，0、1、2、3 是分布式系统中的节点成员，其中由 0 节点提议区块，1、2、3节点对提议出来的区块进行投票，其中 3 节点已发生故障。我们默认3发送信息为无效。那么PBFT算法执行的流程如下：

- C发起一笔请求到0号节点
- 节点0开始对请求排序编号，并把请求序号发送到1、2、3节点
- 1、2节点互相之间和0节点之间发送消息
- 0、1、2之间确认0节点的分配序号，互相确认
- 0、1、2确认信息回复C
- 客户端C判断收到确认是否在2f\+1内，确认结果

在每一轮共识分三个阶段达成共识（核心步骤）：Pre\-Prepare、Prepare和Commit，整个流程如下：

- 从全网节点选举出一个提议节点（Proposer），新区块由提议节点负责生成
- 每个节点把客户端发来的交易向全网广播，提议节点将从网络收集到需放在新区块内的多个交易排序后存入列表，并将该列表向全网广播
- 每个节点接收到交易列表后，根据排序模拟执行这些交易。所有交易执行完后，基于交易结果计算新区块的哈希摘要，并向全网广播
- 如果一个节点收到的2f条来自其它节点发来的摘要都和自己的相同，就向全网广播一条commit消息
- 如果一个节点收到2f\+1条commit消息，即可提交新区块及其交易到本地的区块链和状态数据库

> 认真读完上面的三阶段共识步骤，你就会明白PBFT为什么这么快

### 5. 迅雷链共识算法

迅雷链采用了同构多链架构，将不同的账户锚定在不同的同构链上，然后接入层将交易路由到发送方所在的链上进行区块打包与共识

共识成功的区块中的交易会根据接收方所在的链的不同，跨链转发到相应的链上。若交易接收方与发送方同属于一条链，则不再进行交易转发

在每一条同构链上，验证人节点对打包好交易的区块进行共识。共识采用优化过的PBFT算法

![ThunderChain共识](http://blog.lpc-win32.com/img/2018-11-22/6.jpg)

以处于某一区块高度的共识操作为例，由于共识的达成需要超过2\/3的节点确认，因此每一次共识可能需要多轮投票才能达成

与传统的PBFT算法类似，对于每一轮共识操作，又包括三个阶段：Propose，Prevote和Precommit

当在某一轮达成共识 (收到\+2\/3的Precommit投票) 后，就会进入对下一个高度的共识，从第0轮开始

下面简单介绍下详细的步骤：

首先介绍关于锁定区块的概念，表示在某个特定的高度和轮数，节点对某个块收到超过节点总数2\/3的Prevote投票集合后，则此节点对于此高度此轮的区块进行锁定。也就是说，节点以锁定区块来表示对某一个区块的认可

- Propose阶段：系统中所有验证人节点(轮流)作为提议者提出提议，而系统中非提议者的节点在收到提议后，就会进入Prevote阶段。如果当前节点此前存在已锁定区块，则还需要收集所有针对已锁定区块的Prevote投票
- PreVote阶段：当节点进入到Prevote阶段后，每个节点广播自己的PreVote投票

> 如果当前区块高度或投票轮数高于此前已锁定的区块高度或轮数，则将原锁定的区块进行解锁  
如果此时节点仍含有未解锁的区块，则对此锁定的区块投PreVote投票  
或者如果节点收到合法的Propose区块，则对此区块投PreVote投票

当preVote阶段超时或者接收到大于2\/3的针对某个块的投票后，则节点锁定此区块并进入PreCommit阶段

- PreCommit阶段：当节点存在已锁定区块，则对此区块投PreCommit投票。当节点收到针对已锁定区块大于2\/3的PreCommit投票是，就可以将这个块 Commit，并且进入针对下一个高度块的共识。若PreCommit阶段定时器超时，则节点保存已锁定区块，然后重新返回到Propose阶段

各节点通过在以上阶段上循环，对区块进行一致性共识。与PBFT算法类似，迅雷链共识也经过了三阶段提交，但通过引入区块锁定操作，通过缓存待确认区块，降低了未达成共识情况下重复通信区块带来的网络压力，从而提升了共识效率

### 6. 小结

PBFT在很多场景都有应用，在区块链场景中，一般适合于对强一致性有要求的私有链和联盟链场景。例如，在IBM主导的区块链超级账本项目中，PBFT是一个可选的共识协议。在Hyperledger的Fabric项目中，共识模块被设计成可插拔的模块，支持像PBFT、Raft等共识算法
